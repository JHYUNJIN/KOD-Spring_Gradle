use kod;


-- 분기 통계
SELECT  
    SALES_STATISTICS.YEAR AS '년',
    SALES_STATISTICS.QUARTER AS '분기', 
    SALES_STATISTICS.PRODUCT_ID as '상품ID',
    SALES_STATISTICS.PRODUCT_NAME AS '상품명',
    SALES_STATISTICS.PRODUCT_PRICE AS '상품가격',
    SALES_STATISTICS.PRODUCT_SALES_QUANTITY AS '상품별판매수량',
    QUARTERLY_SALES.TOTAL_PRODUCT_SALES_QUANTITY_FOR_QUARTER AS '분기동안 상품판매수량',
    FLOOR(SALES_STATISTICS.PRODUCT_SALES_REVENUE) AS '상품매출', 
    FLOOR(QUARTERLY_SALES.QUARTERLY_REVENUE) as '분기별매출'
FROM ( 
    SELECT  
        YEAR(OL.ORDERLIST_DATE) AS 'YEAR', 
        QUARTER(OL.ORDERLIST_DATE) AS 'QUARTER', 
        P.PRODUCT_ID, 
        P.PRODUCT_NAME, 
        P.PRODUCT_PRICE, 
        SUM(OC.ORDERCONTENT_CNT) AS 'PRODUCT_SALES_QUANTITY', 
        SUM((P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT) - (P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT * IFNULL(C.COUPON_DISCOUNT_RATE, 0) / 100)) AS 'PRODUCT_SALES_REVENUE' 
    FROM  
        ORDERLIST OL 
    JOIN  
        ORDERCONTENT OC ON OL.ORDERLIST_ID = OC.ORDERLIST_ID 
    JOIN  
        PRODUCT P ON OC.PRODUCT_ID = P.PRODUCT_ID 
    LEFT JOIN  
        COUPON_STATUS CS ON OC.ORDERCONTENT_ID = CS.ORDERCONTENT_ID 
    LEFT JOIN  
        COUPON C ON CS.COUPON_ID = C.COUPON_ID 
    GROUP BY  
        YEAR(OL.ORDERLIST_DATE), 
        QUARTER(OL.ORDERLIST_DATE), 
        P.PRODUCT_ID, 
        P.PRODUCT_NAME, 
        P.PRODUCT_PRICE 
) AS SALES_STATISTICS 
LEFT JOIN ( 
    SELECT  
        YEAR(OL.ORDERLIST_DATE) AS 'YEAR', 
        QUARTER(OL.ORDERLIST_DATE) AS 'QUARTER', 
        FLOOR(SUM((P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT) - (P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT * IFNULL(C.COUPON_DISCOUNT_RATE, 0) / 100))) AS 'QUARTERLY_REVENUE',
        SUM(OC.ORDERCONTENT_CNT) AS 'TOTAL_PRODUCT_SALES_QUANTITY_FOR_QUARTER'
    FROM  
        ORDERLIST OL 
    JOIN  
        ORDERCONTENT OC ON OL.ORDERLIST_ID = OC.ORDERLIST_ID 
    JOIN  
        PRODUCT P ON OC.PRODUCT_ID = P.PRODUCT_ID 
    LEFT JOIN  
        COUPON_STATUS CS ON OC.ORDERCONTENT_ID = CS.ORDERCONTENT_ID 
    LEFT JOIN  
        COUPON C ON CS.COUPON_ID = C.COUPON_ID 
    GROUP BY  
        YEAR(OL.ORDERLIST_DATE), 
        QUARTER(OL.ORDERLIST_DATE) 
) AS QUARTERLY_SALES ON SALES_STATISTICS.YEAR = QUARTERLY_SALES.YEAR AND SALES_STATISTICS.QUARTER = QUARTERLY_SALES.QUARTER 
ORDER BY  
    SALES_STATISTICS.YEAR, 
    SALES_STATISTICS.QUARTER, 
    SALES_STATISTICS.PRODUCT_SALES_REVENUE DESC;
   
    
    
-- 분기통계 for 3years
SELECT  
    SALES_STATISTICS.YEAR AS '년',
    SALES_STATISTICS.QUARTER AS '분기', 
    SALES_STATISTICS.PRODUCT_ID as '상품ID',
    SALES_STATISTICS.PRODUCT_NAME AS '상품명',
    SALES_STATISTICS.PRODUCT_PRICE AS '상품가격',
    SALES_STATISTICS.PRODUCT_SALES_QUANTITY AS '판매수량',
    QUARTERLY_SALES.TOTAL_QUANTITY AS '분기별총판매수량',  -- 총 판매 수량을 나타내는 새로운 열 추가
    FLOOR(SALES_STATISTICS.PRODUCT_SALES_REVENUE) AS '상품매출', 
    FLOOR(QUARTERLY_SALES.QUARTERLY_REVENUE) as '분기별매출'
FROM ( 
    SELECT  
        YEAR(OL.ORDERLIST_DATE) AS 'YEAR', 
        QUARTER(OL.ORDERLIST_DATE) AS 'QUARTER', 
        P.PRODUCT_ID, 
        P.PRODUCT_NAME, 
        P.PRODUCT_PRICE, 
        SUM(OC.ORDERCONTENT_CNT) AS 'PRODUCT_SALES_QUANTITY', 
        SUM((P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT) - (P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT * IFNULL(C.COUPON_DISCOUNT_RATE, 1) / 100)) AS 'PRODUCT_SALES_REVENUE' 
    FROM  
        ORDERLIST OL 
    JOIN  
        ORDERCONTENT OC ON OL.ORDERLIST_ID = OC.ORDERLIST_ID 
    JOIN  
        PRODUCT P ON OC.PRODUCT_ID = P.PRODUCT_ID 
    LEFT JOIN  
        COUPON_STATUS CS ON OC.ORDERCONTENT_ID = CS.ORDERCONTENT_ID 
    LEFT JOIN  
        COUPON C ON CS.COUPON_ID = C.COUPON_ID 
    WHERE
        OL.ORDERLIST_DATE >= DATE_FORMAT(CURDATE() - INTERVAL 24 MONTH, '%Y-%m-01') 
        AND OL.ORDERLIST_DATE < DATE_FORMAT(CURDATE() + INTERVAL 1 MONTH, '%Y-%m-01') -- 현재 분기부터 3년 전까지의 데이터를 조회하도록 변경
    GROUP BY  
        YEAR(OL.ORDERLIST_DATE), 
        QUARTER(OL.ORDERLIST_DATE), 
        P.PRODUCT_ID, 
        P.PRODUCT_NAME, 
        P.PRODUCT_PRICE 
) AS SALES_STATISTICS 
LEFT JOIN ( 
    SELECT  
        YEAR(OL.ORDERLIST_DATE) AS 'YEAR', 
        QUARTER(OL.ORDERLIST_DATE) AS 'QUARTER', 
        FLOOR(SUM((P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT) - (P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT * IFNULL(C.COUPON_DISCOUNT_RATE, 1) / 100))) AS 'QUARTERLY_REVENUE',
        SUM(OC.ORDERCONTENT_CNT) AS 'TOTAL_QUANTITY'  -- 각 분기별 총 판매 수량을 계산하여 나타내는 새로운 열 추가
    FROM  
        ORDERLIST OL 
    JOIN  
        ORDERCONTENT OC ON OL.ORDERLIST_ID = OC.ORDERLIST_ID 
    JOIN  
        PRODUCT P ON OC.PRODUCT_ID = P.PRODUCT_ID 
    LEFT JOIN  
        COUPON_STATUS CS ON OC.ORDERCONTENT_ID = CS.ORDERCONTENT_ID 
    LEFT JOIN  
        COUPON C ON CS.COUPON_ID = C.COUPON_ID 
    WHERE
        OL.ORDERLIST_DATE >= DATE_FORMAT(CURDATE() - INTERVAL 24 MONTH, '%Y-%m-01') 
        AND OL.ORDERLIST_DATE < DATE_FORMAT(CURDATE() + INTERVAL 1 MONTH, '%Y-%m-01') -- 현재 분기부터 3년 전까지의 데이터를 조회하도록 변경
    GROUP BY  
        YEAR(OL.ORDERLIST_DATE), 
        QUARTER(OL.ORDERLIST_DATE) 
) AS QUARTERLY_SALES ON SALES_STATISTICS.YEAR = QUARTERLY_SALES.YEAR AND SALES_STATISTICS.QUARTER = QUARTERLY_SALES.QUARTER 
ORDER BY  
    SALES_STATISTICS.YEAR, 
    SALES_STATISTICS.QUARTER, 
    SALES_STATISTICS.PRODUCT_SALES_REVENUE DESC;


-- 분기 매출 for 2years
SELECT 
    YEAR(OL.ORDERLIST_DATE) AS '년',
    QUARTER(OL.ORDERLIST_DATE) AS '분기',
    FLOOR(SUM((P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT) - (P.PRODUCT_PRICE * OC.ORDERCONTENT_CNT * IFNULL(C.COUPON_DISCOUNT_RATE, 0) / 100))) AS '분기매출'
FROM 
    ORDERLIST OL
JOIN 
    ORDERCONTENT OC ON OL.ORDERLIST_ID = OC.ORDERLIST_ID
JOIN 
    PRODUCT P ON OC.PRODUCT_ID = P.PRODUCT_ID
LEFT JOIN 
    COUPON_STATUS CS ON OC.ORDERCONTENT_ID = CS.ORDERCONTENT_ID
LEFT JOIN 
    COUPON C ON CS.COUPON_ID = C.COUPON_ID
WHERE 
    OL.ORDERLIST_DATE >= DATE_SUB(CURDATE(), INTERVAL 2 YEAR)
    AND OL.ORDERLIST_DATE <= CURDATE()  
GROUP BY 
    YEAR(OL.ORDERLIST_DATE),
    QUARTER(OL.ORDERLIST_DATE)
ORDER BY 
    YEAR(OL.ORDERLIST_DATE),
    QUARTER(OL.ORDERLIST_DATE);
    
    
-- 일간 매출 for 30days
-- 날짜 범위에 맞는 주문 목록, 주문 내용, 제품, 쿠폰 상태 및 쿠폰 정보를 가져오기 위해 사용
-- CROSS JOIN은 날짜 범위를 생성하는 데 사용
-- LEFT조인을 사용한 이유
-- LEFT JOIN은 생성된 날짜 범위에 따라 주문 목록, 주문 내용, 제품, 쿠폰 상태 및 쿠폰 정보를 가져오는 데 사용
-- 날짜 범위에 주문이 없는 경우를 처리하기 위해, 날짜 범위를 생성하는 서브쿼리는 특정 날짜에 대한 주문이 없는 경우에도 결과에 해당하는 날짜를 포함됨
-- 주문 목록, 주문 내용, 제품, 쿠폰 상태 및 쿠폰 정보 테이블에 날짜 범위에 해당하는 데이터가 없을 수 경우 결과에 해당 날짜를 포함시키기 위함
SELECT 
    YEAR(date_range.date) AS '년',
    MONTH(date_range.date) AS '월',
    DAY(date_range.date) AS '일',
    COALESCE(FLOOR(SUM((pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE) - (pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE * IFNULL(c.COUPON_DISCOUNT_RATE, 0) / 100))), 0) AS '일매출'
FROM 
    (SELECT CURDATE() - INTERVAL (TEN_DIGIT.i + ONE_DIGIT.i) DAY AS date
     FROM
         (SELECT 0 AS i UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL
          SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS ONE_DIGIT
     CROSS JOIN -- 날짜의 범위를 생성하기 위해 사용된 coress join
         (SELECT 0 AS i UNION ALL SELECT 10 UNION ALL SELECT 20 UNION ALL SELECT 30) AS TEN_DIGIT) AS date_range
LEFT JOIN 
    ORDERLIST ol ON DATE(ol.ORDERLIST_DATE) = date_range.date
LEFT JOIN 
    ORDERCONTENT pc ON ol.ORDERLIST_ID = pc.ORDERLIST_ID
LEFT JOIN 
    PRODUCT p ON pc.PRODUCT_ID = p.PRODUCT_ID
LEFT JOIN 
    COUPON_STATUS cs ON pc.ORDERCONTENT_ID = cs.ORDERCONTENT_ID
LEFT JOIN 
    COUPON c ON cs.COUPON_ID = c.COUPON_ID
WHERE 
    date_range.date >= CURDATE() - INTERVAL 31 DAY 
    AND date_range.date < CURDATE()+1 -- CURDATE()+1 == DATE_ADD(CURDATE(), INTERVAL 1 DAY)
GROUP BY 
    YEAR(date_range.date),
    MONTH(date_range.date),
    DAY(date_range.date)
ORDER BY 
    YEAR(date_range.date),
    MONTH(date_range.date),
    DAY(date_range.date);
    
    
    
-- 1년간 월간매출 for 13month
SELECT 
    YEAR(ol.ORDERLIST_DATE) AS 'YEAR',
    MONTH(ol.ORDERLIST_DATE) AS 'MONTH',
    FLOOR(SUM((pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE) - (pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE * IFNULL(c.COUPON_DISCOUNT_RATE, 0) / 100))) AS 'MONTHLY_REVENUE'
FROM 
    ORDERLIST ol
INNER JOIN 
    ORDERCONTENT pc ON ol.ORDERLIST_ID = pc.ORDERLIST_ID
INNER JOIN 
    PRODUCT p ON pc.PRODUCT_ID = p.PRODUCT_ID
LEFT JOIN 
    COUPON_STATUS cs ON pc.ORDERCONTENT_ID = cs.ORDERCONTENT_ID
LEFT JOIN 
    COUPON c ON cs.COUPON_ID = c.COUPON_ID
WHERE 
    ol.ORDERLIST_DATE >= DATE_FORMAT(CURDATE() - INTERVAL 12 MONTH, '%Y-%m-01') 
    AND ol.ORDERLIST_DATE < DATE_FORMAT(CURDATE() + INTERVAL 1 MONTH, '%Y-%m-01')
GROUP BY 
    YEAR(ol.ORDERLIST_DATE),
    MONTH(ol.ORDERLIST_DATE)
ORDER BY 
    YEAR(ol.ORDERLIST_DATE),
    MONTH(ol.ORDERLIST_DATE);
    
    

-- 일간 매출 for 30days
-- 날짜 범위에 맞는 주문 목록, 주문 내용, 제품, 쿠폰 상태 및 쿠폰 정보를 가져오기 위해 사용
-- CROSS JOIN은 날짜 범위를 생성하는 데 사용
-- LEFT조인을 사용한 이유
-- LEFT JOIN은 생성된 날짜 범위에 따라 주문 목록, 주문 내용, 제품, 쿠폰 상태 및 쿠폰 정보를 가져오는 데 사용
-- 날짜 범위에 주문이 없는 경우를 처리하기 위해, 날짜 범위를 생성하는 서브쿼리는 특정 날짜에 대한 주문이 없는 경우에도 결과에 해당하는 날짜를 포함됨
-- 주문 목록, 주문 내용, 제품, 쿠폰 상태 및 쿠폰 정보 테이블에 날짜 범위에 해당하는 데이터가 없을 수 경우 결과에 해당 날짜를 포함시키기 위함
SELECT 
    YEAR(date_range.date) AS '년',
    MONTH(date_range.date) AS '월',
    DAY(date_range.date) AS '일',
    COALESCE(
        FLOOR(
            SUM(
                CASE
                    WHEN (pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE * IFNULL(c.COUPON_DISCOUNT_RATE, 0) / 100)
                         > c.COUPON_DISCOUNT_MAX_PRICE
                    THEN
                        (pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE) - c.COUPON_DISCOUNT_MAX_PRICE
                    ELSE
                        (pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE) 
                         - (pc.ORDERCONTENT_CNT * p.PRODUCT_PRICE * IFNULL(c.COUPON_DISCOUNT_RATE, 0) / 100)
                END
            )
        ),
        0
    ) AS '일매출'
FROM 
    (SELECT CURDATE() - INTERVAL (TEN_DIGIT.i + ONE_DIGIT.i) DAY AS date
     FROM
         (SELECT 0 AS i UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL
          SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS ONE_DIGIT
     CROSS JOIN -- 날짜의 범위를 생성하기 위해 사용된 coress join
         (SELECT 0 AS i UNION ALL SELECT 10 UNION ALL SELECT 20 UNION ALL SELECT 30) AS TEN_DIGIT) AS date_range
LEFT JOIN 
    ORDERLIST ol ON DATE(ol.ORDERLIST_DATE) = date_range.date
LEFT JOIN 
    ORDERCONTENT pc ON ol.ORDERLIST_ID = pc.ORDERLIST_ID
LEFT JOIN 
    PRODUCT p ON pc.PRODUCT_ID = p.PRODUCT_ID
LEFT JOIN 
    COUPON_STATUS cs ON pc.ORDERCONTENT_ID = cs.ORDERCONTENT_ID
LEFT JOIN 
    COUPON c ON cs.COUPON_ID = c.COUPON_ID
WHERE 
    date_range.date >= CURDATE() - INTERVAL 31 DAY 
    AND date_range.date < CURDATE()+1 -- CURDATE()+1 == DATE_ADD(CURDATE(), INTERVAL 1 DAY)
GROUP BY 
    YEAR(date_range.date),
    MONTH(date_range.date),
    DAY(date_range.date)
ORDER BY 
    YEAR(date_range.date),
    MONTH(date_range.date),
    DAY(date_range.date);